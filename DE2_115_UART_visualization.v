
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE2_115_UART_visualization(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,

	//////////// Sma //////////
	input 		          		SMA_CLKIN,
	output		          		SMA_CLKOUT,

	//////////// LED //////////
	output		     [8:0]		LEDG,
	output		    [17:0]		LEDR,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// EX_IO //////////
	inout 		     [6:0]		EX_IO,

	//////////// SW //////////
	input 		    [17:0]		SW,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,
	output		     [6:0]		HEX6,
	output		     [6:0]		HEX7,

	//////////// RS232 //////////
	input 		          		UART_CTS,
	output		          		UART_RTS,
	input 		          		UART_RXD,
	output		          		UART_TXD,

	//////////// VGA //////////
	output		     [7:0]		VGA_B,
	output		          		VGA_BLANK_N,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// SRAM //////////
	output		    [19:0]		SRAM_ADDR,
	output		          		SRAM_CE_N,
	inout 		    [15:0]		SRAM_DQ,
	output		          		SRAM_LB_N,
	output		          		SRAM_OE_N,
	output		          		SRAM_UB_N,
	output		          		SRAM_WE_N
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
    wire F78M75;
	wire VGA_BLANK_N_without_del;
    wire V_BLANK_N_without_del;
    wire [11:0]counterPclkH;
    wire [9:0]counterLines;
    wire [15:0]data_out;
    wire [15:0]data_in;
    wire EoFrame;

    wire pressBTN_0;
    wire depressBTN_0;
    wire pressBTN_1;
    wire depressBTN_1;
    wire pressBTN_2;
    wire pressBTN_3;

    wire clr;
    wire column_clr;
    wire EOL;
	wire en_shift;
	wire ce_addr;
    wire parity_counterPclkH;
    wire [9:0]shift_counter;
    wire [9:0]par;
    wire valid_data;

    wire uart_data_in;
    wire [127:0]uart_data_out;

    reg debug_button = 0;
    reg stop = 0;
	wire clr_end;
	reg t_clr = 0;

    wire [9:0]param1;
    wire [9:0]param2;
    wire [9:0]param3;
    wire [9:0]param4;
    reg [39:0]parameters = 0;

    wire [2:0]presented_double_byte;

    wire [15:0]desh;

    wire [39:0]ver_data;
    wire ver_valid;

    reg [6:0]segments = 0;



//=======================================================
//  Structural coding
//=======================================================


    F78m75	F78m75_inst (.inclk0 ( CLOCK_50 ), .c0 ( F78M75 ));

    VGA_signals VGA_signals (.pixel_clk(F78M75), .delay_VGA_SYNC_N(VGA_SYNC_N), .delay_VGA_BLANK_N(VGA_BLANK_N), .delay_HSYNC(VGA_HS), .delay_VSYNC(VGA_VS), .counterPclkH(counterPclkH), .counterLines(counterLines), .VGA_BLANK_N(VGA_BLANK_N_without_del), .EoFrame(EoFrame), .V_BLANK_N(V_BLANK_N_without_del), .EOL(EOL), .valid_data(valid_data));

    SRAM SRAM (.pixel_clk(F78M75), .address(SRAM_ADDR), .data_out(data_out), .RED(VGA_R), .GREEN(VGA_G), .BLUE(VGA_B), .counterPclkH(counterPclkH), .counterLines(counterLines), .clr(clr), .DWr(data_in), .stop(stop), .column_clr(column_clr), .shift_counter(shift_counter), .en_shift(en_shift), .ce_addr(ce_addr), .parity_counterPclkH(parity_counterPclkH), .S(pressBTN_0), .valid_data(valid_data), .param1(param1), .param2(param2), .param3(param3), .param4(param4));

    SRAM_control SRAM_control (.pixel_clk(F78M75), .nCE(SRAM_CE_N), .nOE(SRAM_OE_N), .nWE(SRAM_WE_N), .nLB(SRAM_LB_N), .nUB(SRAM_UB_N), .S(pressBTN_0), .R(depressBTN_0), .counterPclkH(counterPclkH), .clr(clr), .counterLines(counterLines), .en_shift(en_shift), .ce_addr(ce_addr), .parity_counterPclkH(parity_counterPclkH), .shift_counter(shift_counter));

    button button_0 (.clk(F78M75), .key(KEY[0]), .moment_of_press(pressBTN_0), .moment_of_depress(depressBTN_0));

    button button_1 (.clk(F78M75), .key(KEY[1]), .moment_of_press(pressBTN_1), .moment_of_depress(depressBTN_1));

    button button_2 (.clk(F78M75), .key(KEY[2]), .moment_of_press(pressBTN_2));

    button button_3 (.clk(F78M75), .key(KEY[3]), .moment_of_press(pressBTN_3));

    //Gen_parabola Gen_parabola (.clk(F78M75), .ce(en_shift), .par(par));

    top_uart_rx top_uart_rx (.clk(F78M75), .RXD(uart_data_in), .univ_com_wire(uart_data_out), .valid_data(valid_data), .en_shift(en_shift));
    
    top_uart_trans top_uart_trans (.clk(F78M75), .TXD(uart_data_in), .ver_data(ver_data), .ver_valid(ver_valid), .en_shift(en_shift));

    BTN_counter BTN_counter (.clk(F78M75), .btn2(pressBTN_2), .btn3(pressBTN_3), .counter(presented_double_byte));

    always @(posedge F78M75)
    begin    
        //parameters[SW[1:0]*10 +: 10] <= uart_data_out[(presented_double_byte + 1)*16 + SW[2]*8 - 10 +: 10];
        parameters[9:0] <= ((SW[1:0] == 0) & SW[2]) ? uart_data_out[(presented_double_byte + 1)*16 - 2 +: 10] : ((SW[1:0] == 0) & ~SW[2]) ? uart_data_out[(presented_double_byte + 1)*16 - 10 +: 10] : parameters[9:0];

        parameters[19:10] <= ((SW[1:0] == 2'b01) & SW[2]) ? uart_data_out[(presented_double_byte + 1)*16 - 2 +: 10] : ((SW[1:0] == 2'b01) & ~SW[2]) ? uart_data_out[(presented_double_byte + 1)*16 - 10 +: 10] : parameters[19:10];

        parameters[29:20] <= ((SW[1:0] == 2'b10) & SW[2]) ? uart_data_out[(presented_double_byte + 1)*16 - 2 +: 10] : ((SW[1:0] == 2'b10) & ~SW[2]) ? uart_data_out[(presented_double_byte + 1)*16 - 10 +: 10] : parameters[29:20];

        parameters[39:30] <= ((SW[1:0] == 2'b11) & SW[2]) ? uart_data_out[(presented_double_byte + 1)*16 - 2 +: 10] : ((SW[1:0] == 2'b11) & ~SW[2]) ? uart_data_out[(presented_double_byte + 1)*16 - 10 +: 10] : parameters[39:30];
        
        /*parameters[9:0] <= uart_data_out[15:6] ;
        parameters[19:10] <= uart_data_out[31:22];
        parameters[29:20] <= uart_data_out[47:38];
        parameters[39:30] <= uart_data_out[63:54];*/
        

    end

    /*assign param1 = parameters[9:0];
    assign param2 = parameters[19:10];
    assign param3 = parameters[29:20];
    assign param4 = parameters[39:30];*/

    assign param1 = uart_data_out[15:6];
    assign param2 = uart_data_out[31:22];
    assign param3 = uart_data_out[47:38];
    assign param4 = uart_data_out[63:54];


    always @(posedge F78M75)
    begin
        stop <=  pressBTN_1 ? ~stop : stop;
		t_clr <= parity_counterPclkH ? clr : t_clr;        
    end

    genvar i;
    generate
		for( i = 0; i < 16; i = i+1 )
		begin: led
			assign desh[i] = ((i == 2*(presented_double_byte + 1) + SW[2] - 1) | (i == 2*(presented_double_byte + 1) + SW[2] - 2));
		end
	endgenerate	

    assign LEDR[17:2] = SW[17:2] | desh;
    assign LEDR[0] = SW[0] | (~SRAM_WE_N);
    assign LEDR[1] = SW[1] | debug_button;

    assign VGA_CLK = F78M75;

    assign SRAM_DQ = SRAM_WE_N ? 16'hZZZZ : (t_clr) ? SW[17:2] : data_in;
    assign data_out = SRAM_DQ;

    assign LEDG[5:0] = 6'b1;
    assign LEDG[7] = (ver_data == uart_data_out);
	 assign LEDG[6] = valid_data;

    always @(posedge pressBTN_0)
    begin
        debug_button <= ~debug_button;
    end
	 
	assign clr_end = ~clr & t_clr;

    always @(*) 
    begin
        case (presented_double_byte)/* abcdefg */
            4'h0: segments_saw =    7'b1000000;
            4'h1: segments_saw =    7'b1111001;
            4'h2: segments_saw =    7'b0100100;
            4'h3: segments_saw =    7'b0110000;
            4'h4: segments_saw =    7'b0011001;
            4'h5: segments_saw =    7'b0010010;
            4'h6: segments_saw =    7'b0000010;
            4'h7: segments_saw =    7'b1111000;
            4'h8: segments_saw =    7'b0000000;
            4'h9: segments_saw =    7'b0010000;
            4'ha: segments_saw = 7'b0001000;
            4'hb: segments_saw = 7'b0000011;
            4'hc: segments_saw = 7'b1000110;
            4'hd: segments_saw = 7'b0100001;
            4'he: segments_saw = 7'b0000011;
            4'hF: segments_saw = 7'b0001110;
            default: segments_saw = 7'b1111111;
        endcase
    end

    always @(*) 
    begin
        case (presented_double_byte)/* abcdefg */
            4'h0: segments =    7'b1000000;
            4'h1: segments =    7'b1111001;
            4'h2: segments =    7'b0100100;
            4'h3: segments =    7'b0110000;
            4'h4: segments =    7'b0011001;
            4'h5: segments =    7'b0010010;
            4'h6: segments =    7'b0000010;
            4'h7: segments =    7'b1111000;
            4'h8: segments =    7'b0000000;
            4'h9: segments =    7'b0010000;
            4'ha: segments = 7'b0001000;
            4'hb: segments = 7'b0000011;
            4'hc: segments = 7'b1000110;
            4'hd: segments = 7'b0100001;
            4'he: segments = 7'b0000011;
            4'hF: segments = 7'b0001110;
            default: segments = 7'b1111111;
        endcase
    end
	
	assign HEX0 = segments;
	assign HEX1 = segments_saw;
	assign HEX2 = 7'd1111111;
	assign HEX3 = 7'd1111111;
	assign HEX4 = 7'd1111111;
	assign HEX5 = 7'd1111111;
	assign HEX6 = 7'd1111111;
	assign HEX7 = 7'd1111111;

endmodule
